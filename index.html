<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FAQ Accordion</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <div class="container mt-5">
        <h2 class="mb-4">FAQ</h2>
        <div class="accordion" id="faqAccordion">
            <!-- Question 1 -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading1">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1" aria-expanded="true" aria-controls="collapse1">
                        1. Hooks
                    </button>
                </h2>
                <div id="collapse1" class="accordion-collapse collapse show" aria-labelledby="heading1" data-bs-parent="#faqAccordion">
                    <div class="accordion-body">
                        Hook: A function that lets you use React state and lifecycle features in functional components.<br>
                        <strong>useState:</strong> Manages local state in a functional component.<br>
                        <strong>useEffect:</strong> Performs side effects, like data fetching or subscriptions, after rendering.<br>
                        <strong>useMemo:</strong> Caches a computed value, re-calculating it only when dependencies change.<br>
                        <strong>useRef:</strong> Stores a mutable reference that persists across renders, often for DOM manipulation.<br>
                        <strong>useContext:</strong> Accesses values from React's Context API in a component without prop drilling.<br>
                        <strong>useCallback:</strong> Memoizes a function to prevent unnecessary re-creation on re-renders.<br>
                        <strong>useReducer:</strong> Manages complex state logic, often used as an alternative to useState with reducers.
                    </div>
                </div>
            </div>
            <!-- Question 2 -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading2">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2" aria-expanded="false" aria-controls="collapse2">
                        2. Promises
                    </button>
                </h2>
                <div id="collapse2" class="accordion-collapse collapse" aria-labelledby="heading2" data-bs-parent="#faqAccordion">
                    <div class="accordion-body">
                        Promises are objects that represent the eventual completion (or failure) of an asynchronous operation.<br>
                        <strong>States:</strong><br>
                        <strong>Pending:</strong> The operation is still in progress.<br>
                        <strong>Fulfilled:</strong> The operation was successful.<br>
                        <strong>Rejected:</strong> The operation failed.
                    </div>
                </div>
            </div>
            <!-- Question 3 -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading3">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3" aria-expanded="false" aria-controls="collapse3">
                        3. Closures
                    </button>
                </h2>
                <div id="collapse3" class="accordion-collapse collapse" aria-labelledby="heading3" data-bs-parent="#faqAccordion">
                    <div class="accordion-body">
                        A closure in JavaScript is a function that remembers its lexical scope (the variables from its outer function) even after the outer function has finished executing.<br>
                        It allows the inner function to access variables from the outer function's scope, even if the outer function has returned.
                    </div>
                </div>
            </div>
            <!-- Question 4 -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading4">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4" aria-expanded="false" aria-controls="collapse4">
                        4. Callback
                    </button>
                </h2>
                <div id="collapse4" class="accordion-collapse collapse" aria-labelledby="heading4" data-bs-parent="#faqAccordion">
                    <div class="accordion-body">
                        A callback is a function passed as an argument to another function, which is then executed once the task is completed. Itâ€™s commonly used in asynchronous programming to handle actions like data fetching or user input after the operation finishes.
                    </div>
                </div>
            </div>
            <!-- Question 5 -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading5">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5" aria-expanded="false" aria-controls="collapse5">
                        5. useState vs useRef
                    </button>
                </h2>
                <div id="collapse5" class="accordion-collapse collapse" aria-labelledby="heading5" data-bs-parent="#faqAccordion">
                    <div class="accordion-body">
                        useState triggers re-renders, while useRef does not.
                    </div>
                </div>
            </div>
            <!-- Question 6 -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading6">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6" aria-expanded="false" aria-controls="collapse6">
                        6. Currying
                    </button>
                </h2>
                <div id="collapse6" class="accordion-collapse collapse" aria-labelledby="heading6" data-bs-parent="#faqAccordion">
                    <div class="accordion-body">
                        Currying is a technique in JavaScript where a function takes multiple arguments one at a time, returning a new function for each argument until all are provided. This allows partial application of functions.
                    </div>
                </div>
            </div>
            <!-- Question 7 -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading7">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7" aria-expanded="false" aria-controls="collapse7">
                        7. Hoisting
                    </button>
                </h2>
                <div id="collapse7" class="accordion-collapse collapse" aria-labelledby="heading7" data-bs-parent="#faqAccordion">
                    <div class="accordion-body">
                        Hoisting is JavaScript's behavior of moving variable and function declarations to the top of their scope before code execution. Variables declared with var are hoisted and initialized to undefined, while let and const are hoisted but remain in a "temporal dead zone." Function declarations are hoisted with their definitions.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
